// Code generated by counterfeiter. DO NOT EDIT.
package writersfakes

import (
	"sync"

	"github.com/syntasso/kratix/api/v1alpha1"
	"github.com/syntasso/kratix/lib/writers"
)

type FakeStateStoreWriter struct {
	RemoveObjectStub        func(string) error
	removeObjectMutex       sync.RWMutex
	removeObjectArgsForCall []struct {
		arg1 string
	}
	removeObjectReturns struct {
		result1 error
	}
	removeObjectReturnsOnCall map[int]struct {
		result1 error
	}
	WriteDirWithObjectsStub        func(bool, string, ...v1alpha1.Workload) error
	writeDirWithObjectsMutex       sync.RWMutex
	writeDirWithObjectsArgsForCall []struct {
		arg1 bool
		arg2 string
		arg3 []v1alpha1.Workload
	}
	writeDirWithObjectsReturns struct {
		result1 error
	}
	writeDirWithObjectsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStateStoreWriter) RemoveObject(arg1 string) error {
	fake.removeObjectMutex.Lock()
	ret, specificReturn := fake.removeObjectReturnsOnCall[len(fake.removeObjectArgsForCall)]
	fake.removeObjectArgsForCall = append(fake.removeObjectArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveObjectStub
	fakeReturns := fake.removeObjectReturns
	fake.recordInvocation("RemoveObject", []interface{}{arg1})
	fake.removeObjectMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateStoreWriter) RemoveObjectCallCount() int {
	fake.removeObjectMutex.RLock()
	defer fake.removeObjectMutex.RUnlock()
	return len(fake.removeObjectArgsForCall)
}

func (fake *FakeStateStoreWriter) RemoveObjectCalls(stub func(string) error) {
	fake.removeObjectMutex.Lock()
	defer fake.removeObjectMutex.Unlock()
	fake.RemoveObjectStub = stub
}

func (fake *FakeStateStoreWriter) RemoveObjectArgsForCall(i int) string {
	fake.removeObjectMutex.RLock()
	defer fake.removeObjectMutex.RUnlock()
	argsForCall := fake.removeObjectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateStoreWriter) RemoveObjectReturns(result1 error) {
	fake.removeObjectMutex.Lock()
	defer fake.removeObjectMutex.Unlock()
	fake.RemoveObjectStub = nil
	fake.removeObjectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateStoreWriter) RemoveObjectReturnsOnCall(i int, result1 error) {
	fake.removeObjectMutex.Lock()
	defer fake.removeObjectMutex.Unlock()
	fake.RemoveObjectStub = nil
	if fake.removeObjectReturnsOnCall == nil {
		fake.removeObjectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeObjectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateStoreWriter) WriteDirWithObjects(arg1 bool, arg2 string, arg3 ...v1alpha1.Workload) error {
	fake.writeDirWithObjectsMutex.Lock()
	ret, specificReturn := fake.writeDirWithObjectsReturnsOnCall[len(fake.writeDirWithObjectsArgsForCall)]
	fake.writeDirWithObjectsArgsForCall = append(fake.writeDirWithObjectsArgsForCall, struct {
		arg1 bool
		arg2 string
		arg3 []v1alpha1.Workload
	}{arg1, arg2, arg3})
	stub := fake.WriteDirWithObjectsStub
	fakeReturns := fake.writeDirWithObjectsReturns
	fake.recordInvocation("WriteDirWithObjects", []interface{}{arg1, arg2, arg3})
	fake.writeDirWithObjectsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateStoreWriter) WriteDirWithObjectsCallCount() int {
	fake.writeDirWithObjectsMutex.RLock()
	defer fake.writeDirWithObjectsMutex.RUnlock()
	return len(fake.writeDirWithObjectsArgsForCall)
}

func (fake *FakeStateStoreWriter) WriteDirWithObjectsCalls(stub func(bool, string, ...v1alpha1.Workload) error) {
	fake.writeDirWithObjectsMutex.Lock()
	defer fake.writeDirWithObjectsMutex.Unlock()
	fake.WriteDirWithObjectsStub = stub
}

func (fake *FakeStateStoreWriter) WriteDirWithObjectsArgsForCall(i int) (bool, string, []v1alpha1.Workload) {
	fake.writeDirWithObjectsMutex.RLock()
	defer fake.writeDirWithObjectsMutex.RUnlock()
	argsForCall := fake.writeDirWithObjectsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStateStoreWriter) WriteDirWithObjectsReturns(result1 error) {
	fake.writeDirWithObjectsMutex.Lock()
	defer fake.writeDirWithObjectsMutex.Unlock()
	fake.WriteDirWithObjectsStub = nil
	fake.writeDirWithObjectsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateStoreWriter) WriteDirWithObjectsReturnsOnCall(i int, result1 error) {
	fake.writeDirWithObjectsMutex.Lock()
	defer fake.writeDirWithObjectsMutex.Unlock()
	fake.WriteDirWithObjectsStub = nil
	if fake.writeDirWithObjectsReturnsOnCall == nil {
		fake.writeDirWithObjectsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeDirWithObjectsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateStoreWriter) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.removeObjectMutex.RLock()
	defer fake.removeObjectMutex.RUnlock()
	fake.writeDirWithObjectsMutex.RLock()
	defer fake.writeDirWithObjectsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStateStoreWriter) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ writers.StateStoreWriter = new(FakeStateStoreWriter)
